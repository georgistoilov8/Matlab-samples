function Task2
    % В началото ще зададем начални стойности на х и у и ще отворим един
    % прозорец. В него ще бъдат начертани векторното поле, а също и
    % равновесните точки.
    tmax=10;
    x=-3:0.5:14;
    y=-3:0.2:3;
    axis([-3,14,-3,3]);
    hold on;
    xlabel('x');
    ylabel('y');
    % Намерената равновесна точка след решаване на системата уравнения е
    % (8, 0) или х = 8, у = 0.
    plot(8, 0, 'b*');
    
    % След като сме намерили и начертали точката/ите трябва да се начертае
    % векторното поле. За целта първо ще използваме meshgrid(x,y). Тази
    % функция връща две двумерни матрици с кординати, които са базирани на
    % векторите х и у. Първата матрица е записана в Х, а втората в У. В
    % матрицата Х всеки ред отговаря на вектора х(копие е на х), а за
    % матрицата У имаме, че всяка колона е копие на вектора у. В
    % променливите P и Q записваме системата. D изчисляваме squrt(x^2 +
    % y^2) за съответните х от Х и у от У. И накрая с функцията quiver() се
    % начертава самото векторно поле. Първите два аргумента са координата
    % на началото на вектора, следващите два са посоката на вектора, след
    % това 0.5 е дължината и 'k' е цветът на вектора. Тази функция се
    % прилага за матриците Х и У и така получаваме цялото векторно поле.
    [X,Y]=meshgrid(x,y);
    P = X + Y - 8*exp(2*Y); 
    Q = -X + Y + 8*exp(2*Y);
    D=sqrt(P.^2+Q.^2);
    quiver(X,Y,P./D,Q./D,0.5,'k')
  
    % Следваща стъпка е натискането с клик върху това векторно поле и
    % анимирането на движението по фазовата крива (х(t), y(t)) за t >= 1 &&
    % t <= 10. Началната точка е (х0, у0) въведенеа с клик. Благодарение на
    % getframe се получава бавно начертаване на движението. 
    [x0,y0]=ginput(1);
    [T,Y]=ode45(@ff,[0,tmax],[x0; y0]);
    x=Y(:,1); 
    y=Y(:,2);
    for k=1:length(T)
        xx(k)=x(k); 
        yy(k)=y(k);
        plot(xx,yy,'r');
        getframe;
    end
    function z=ff(~,y)
        z= [y(1)+ y(2) - 8*exp(2*y(2)); -y(1)+ y(2) + 8*exp(2*y(2))];
    end
end
